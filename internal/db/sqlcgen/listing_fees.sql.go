// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: listing_fees.sql

package sqlcgen

import (
	"context"

	"github.com/google/uuid"
)

const createListingFee = `-- name: CreateListingFee :exec
INSERT INTO listing_fees (policy_id, public_key, target_plugin_id, amount, destination, status)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (policy_id) DO NOTHING
`

type CreateListingFeeParams struct {
	PolicyID       uuid.UUID
	PublicKey      string
	TargetPluginID string
	Amount         string
	Destination    string
	Status         string
}

func (q *Queries) CreateListingFee(ctx context.Context, arg CreateListingFeeParams) error {
	_, err := q.db.Exec(ctx, createListingFee,
		arg.PolicyID,
		arg.PublicKey,
		arg.TargetPluginID,
		arg.Amount,
		arg.Destination,
		arg.Status,
	)
	return err
}

const deactivatePolicy = `-- name: DeactivatePolicy :exec
UPDATE plugin_policies
SET active = false, deactivation_reason = $2
WHERE id = $1 AND active = true
`

type DeactivatePolicyParams struct {
	ID                 uuid.UUID
	DeactivationReason *string
}

func (q *Queries) DeactivatePolicy(ctx context.Context, arg DeactivatePolicyParams) error {
	_, err := q.db.Exec(ctx, deactivatePolicy, arg.ID, arg.DeactivationReason)
	return err
}

const getListingFeeByPolicyID = `-- name: GetListingFeeByPolicyID :one
SELECT id, policy_id, public_key, target_plugin_id, amount, destination,
       tx_hash, block_number, confirmations, status,
       submitted_at, paid_at, failure_reason,
       created_at, updated_at
FROM listing_fees
WHERE policy_id = $1
`

func (q *Queries) GetListingFeeByPolicyID(ctx context.Context, policyID uuid.UUID) (ListingFee, error) {
	row := q.db.QueryRow(ctx, getListingFeeByPolicyID, policyID)
	var i ListingFee
	err := row.Scan(
		&i.ID,
		&i.PolicyID,
		&i.PublicKey,
		&i.TargetPluginID,
		&i.Amount,
		&i.Destination,
		&i.TxHash,
		&i.BlockNumber,
		&i.Confirmations,
		&i.Status,
		&i.SubmittedAt,
		&i.PaidAt,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getListingFeeByScope = `-- name: GetListingFeeByScope :one
SELECT id, policy_id, public_key, target_plugin_id, amount, destination,
       tx_hash, block_number, confirmations, status,
       submitted_at, paid_at, failure_reason,
       created_at, updated_at
FROM listing_fees
WHERE public_key = $1 AND target_plugin_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetListingFeeByScopeParams struct {
	PublicKey      string
	TargetPluginID string
}

func (q *Queries) GetListingFeeByScope(ctx context.Context, arg GetListingFeeByScopeParams) (ListingFee, error) {
	row := q.db.QueryRow(ctx, getListingFeeByScope, arg.PublicKey, arg.TargetPluginID)
	var i ListingFee
	err := row.Scan(
		&i.ID,
		&i.PolicyID,
		&i.PublicKey,
		&i.TargetPluginID,
		&i.Amount,
		&i.Destination,
		&i.TxHash,
		&i.BlockNumber,
		&i.Confirmations,
		&i.Status,
		&i.SubmittedAt,
		&i.PaidAt,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaidActivePolicyIDs = `-- name: GetPaidActivePolicyIDs :many
SELECT lf.policy_id
FROM listing_fees lf
JOIN plugin_policies pp ON pp.id = lf.policy_id
WHERE lf.status = 'paid'
  AND pp.active = true
`

func (q *Queries) GetPaidActivePolicyIDs(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getPaidActivePolicyIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var policy_id uuid.UUID
		if err := rows.Scan(&policy_id); err != nil {
			return nil, err
		}
		items = append(items, policy_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingListingFeeByScope = `-- name: GetPendingListingFeeByScope :one
SELECT id, policy_id, public_key, target_plugin_id, amount, destination,
       tx_hash, block_number, confirmations, status,
       submitted_at, paid_at, failure_reason,
       created_at, updated_at
FROM listing_fees
WHERE public_key = $1 AND target_plugin_id = $2 AND status = 'pending'
LIMIT 1
`

type GetPendingListingFeeByScopeParams struct {
	PublicKey      string
	TargetPluginID string
}

func (q *Queries) GetPendingListingFeeByScope(ctx context.Context, arg GetPendingListingFeeByScopeParams) (ListingFee, error) {
	row := q.db.QueryRow(ctx, getPendingListingFeeByScope, arg.PublicKey, arg.TargetPluginID)
	var i ListingFee
	err := row.Scan(
		&i.ID,
		&i.PolicyID,
		&i.PublicKey,
		&i.TargetPluginID,
		&i.Amount,
		&i.Destination,
		&i.TxHash,
		&i.BlockNumber,
		&i.Confirmations,
		&i.Status,
		&i.SubmittedAt,
		&i.PaidAt,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingListingFees = `-- name: GetPendingListingFees :many
SELECT id, policy_id, public_key, target_plugin_id, amount, destination,
       tx_hash, block_number, confirmations, status,
       submitted_at, paid_at, failure_reason,
       created_at, updated_at
FROM listing_fees
WHERE status = 'pending'
`

func (q *Queries) GetPendingListingFees(ctx context.Context) ([]ListingFee, error) {
	rows, err := q.db.Query(ctx, getPendingListingFees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingFee
	for rows.Next() {
		var i ListingFee
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.PublicKey,
			&i.TargetPluginID,
			&i.Amount,
			&i.Destination,
			&i.TxHash,
			&i.BlockNumber,
			&i.Confirmations,
			&i.Status,
			&i.SubmittedAt,
			&i.PaidAt,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmittedListingFees = `-- name: GetSubmittedListingFees :many
SELECT id, policy_id, public_key, target_plugin_id, amount, destination,
       tx_hash, block_number, confirmations, status,
       submitted_at, paid_at, failure_reason,
       created_at, updated_at
FROM listing_fees
WHERE status = 'submitted'
`

func (q *Queries) GetSubmittedListingFees(ctx context.Context) ([]ListingFee, error) {
	rows, err := q.db.Query(ctx, getSubmittedListingFees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingFee
	for rows.Next() {
		var i ListingFee
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.PublicKey,
			&i.TargetPluginID,
			&i.Amount,
			&i.Destination,
			&i.TxHash,
			&i.BlockNumber,
			&i.Confirmations,
			&i.Status,
			&i.SubmittedAt,
			&i.PaidAt,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedPolicyIDs = `-- name: GetUnprocessedPolicyIDs :many
SELECT pp.id
FROM plugin_policies pp
LEFT JOIN listing_fees lf ON lf.policy_id = pp.id
WHERE pp.active = true
  AND lf.id IS NULL
`

func (q *Queries) GetUnprocessedPolicyIDs(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUnprocessedPolicyIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasActiveListingFee = `-- name: HasActiveListingFee :one
SELECT EXISTS(
    SELECT 1 FROM listing_fees
    WHERE public_key = $1
      AND target_plugin_id = $2
      AND status IN ('pending', 'submitted', 'paid')
)
`

type HasActiveListingFeeParams struct {
	PublicKey      string
	TargetPluginID string
}

func (q *Queries) HasActiveListingFee(ctx context.Context, arg HasActiveListingFeeParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasActiveListingFee, arg.PublicKey, arg.TargetPluginID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isListingFeePaidForPlugin = `-- name: IsListingFeePaidForPlugin :one
SELECT EXISTS(
    SELECT 1 FROM listing_fees
    WHERE target_plugin_id = $1
      AND status = 'paid'
)
`

func (q *Queries) IsListingFeePaidForPlugin(ctx context.Context, targetPluginID string) (bool, error) {
	row := q.db.QueryRow(ctx, isListingFeePaidForPlugin, targetPluginID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const markAsFailed = `-- name: MarkAsFailed :exec
UPDATE listing_fees
SET status = 'failed', failure_reason = $2, updated_at = CURRENT_TIMESTAMP
WHERE policy_id = $1 AND status IN ('pending', 'submitted')
`

type MarkAsFailedParams struct {
	PolicyID      uuid.UUID
	FailureReason *string
}

func (q *Queries) MarkAsFailed(ctx context.Context, arg MarkAsFailedParams) error {
	_, err := q.db.Exec(ctx, markAsFailed, arg.PolicyID, arg.FailureReason)
	return err
}

const markAsPaid = `-- name: MarkAsPaid :exec
UPDATE listing_fees
SET status = 'paid', block_number = $2, confirmations = $3, paid_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE policy_id = $1 AND status = 'submitted'
`

type MarkAsPaidParams struct {
	PolicyID      uuid.UUID
	BlockNumber   *int64
	Confirmations int32
}

func (q *Queries) MarkAsPaid(ctx context.Context, arg MarkAsPaidParams) error {
	_, err := q.db.Exec(ctx, markAsPaid, arg.PolicyID, arg.BlockNumber, arg.Confirmations)
	return err
}

const markAsSubmitted = `-- name: MarkAsSubmitted :exec
UPDATE listing_fees
SET status = 'submitted', tx_hash = $2, submitted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE policy_id = $1 AND status = 'pending'
`

type MarkAsSubmittedParams struct {
	PolicyID uuid.UUID
	TxHash   *string
}

func (q *Queries) MarkAsSubmitted(ctx context.Context, arg MarkAsSubmittedParams) error {
	_, err := q.db.Exec(ctx, markAsSubmitted, arg.PolicyID, arg.TxHash)
	return err
}

const syncFailedFees = `-- name: SyncFailedFees :execrows
UPDATE listing_fees lf
SET status = 'failed',
    failure_reason = CASE WHEN ti.lost THEN 'transaction lost' ELSE 'transaction failed on-chain' END,
    updated_at = CURRENT_TIMESTAMP
FROM tx_indexer ti
WHERE ti.policy_id = lf.policy_id
  AND lf.status = 'submitted'
  AND (ti.status_onchain = 'FAIL' OR ti.lost = true)
`

func (q *Queries) SyncFailedFees(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, syncFailedFees)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const syncPaidFees = `-- name: SyncPaidFees :execrows
UPDATE listing_fees lf
SET status = 'paid', paid_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
FROM tx_indexer ti
WHERE ti.policy_id = lf.policy_id
  AND lf.status = 'submitted'
  AND ti.status_onchain = 'SUCCESS'
`

func (q *Queries) SyncPaidFees(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, syncPaidFees)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateConfirmations = `-- name: UpdateConfirmations :exec
UPDATE listing_fees
SET confirmations = $2, updated_at = CURRENT_TIMESTAMP
WHERE policy_id = $1
`

type UpdateConfirmationsParams struct {
	PolicyID      uuid.UUID
	Confirmations int32
}

func (q *Queries) UpdateConfirmations(ctx context.Context, arg UpdateConfirmationsParams) error {
	_, err := q.db.Exec(ctx, updateConfirmations, arg.PolicyID, arg.Confirmations)
	return err
}
